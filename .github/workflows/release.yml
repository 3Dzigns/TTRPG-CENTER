# Release Pipeline for TTRPG Center
# Builds immutable artifacts, deploys to DEV, and enables TEST promotion

name: Release Pipeline

on:
  # Disabled auto-triggers for local-only development; run manually when needed.
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      skip_deploy:
        description: 'Skip automatic DEV deployment'
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: 'Force rebuild even if no changes'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ttrpg/app
  PYTHON_VERSION: '3.11'

permissions:
  contents: write
  packages: write
  id-token: write

jobs:
  # Job 1: Prepare Release
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_version: ${{ steps.version.outputs.build_version }}
      git_sha: ${{ steps.version.outputs.git_sha }}
      timestamp: ${{ steps.version.outputs.timestamp }}
      should_release: ${{ steps.changes.outputs.should_release }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Check for changes since last release
      id: changes
      run: |
        # Get the latest release tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        
        if [ -z "$LATEST_TAG" ]; then
          echo "No previous releases found, proceeding with release"
          echo "should_release=true" >> $GITHUB_OUTPUT
        else
          # Check if there are commits since the last tag
          COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
          
          if [ "$COMMITS_SINCE_TAG" -gt 0 ] || [ "${{ github.event.inputs.force_rebuild }}" == "true" ]; then
            echo "Found $COMMITS_SINCE_TAG commits since $LATEST_TAG, proceeding with release"
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            echo "No commits since $LATEST_TAG, skipping release"
            echo "should_release=false" >> $GITHUB_OUTPUT
          fi
        fi
    
    - name: Setup version management
      if: steps.changes.outputs.should_release == 'true'
      run: |
        # Ensure VERSION file exists
        if [ ! -f VERSION ]; then
          echo "1.0.0" > VERSION
        fi
    
    - name: Determine version bump
      id: version
      if: steps.changes.outputs.should_release == 'true'
      run: |
        CURRENT_VERSION=$(cat VERSION)
        
        # Determine bump type (from workflow input or default to patch)
        BUMP_TYPE="${{ github.event.inputs.bump_type }}"
        if [ -z "$BUMP_TYPE" ]; then
          BUMP_TYPE="patch"
        fi
        
        # Parse current version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        
        # Bump version based on type
        case "$BUMP_TYPE" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          *)
            echo "Invalid bump type: $BUMP_TYPE"
            exit 1
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        
        # Generate build metadata
        GIT_SHA=$(git rev-parse --short=8 HEAD)
        TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
        BUILD_VERSION="${NEW_VERSION}+${GIT_SHA}-${TIMESTAMP}"
        
        # Update VERSION file
        echo "$NEW_VERSION" > VERSION
        
        # Set outputs
        echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
        echo "build_version=${BUILD_VERSION}" >> $GITHUB_OUTPUT
        echo "git_sha=${GIT_SHA}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        
        echo "Version bumped: $CURRENT_VERSION → $NEW_VERSION ($BUMP_TYPE)"
    
    - name: Create version commit and tag
      if: steps.changes.outputs.should_release == 'true'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Commit version update
        git add VERSION
        git commit -m "Release version $VERSION

        🤖 Generated with Claude Code
        
        Co-Authored-By: Claude <noreply@anthropic.com>"
        
        # Create annotated tag
        git tag -a "v$VERSION" -m "Release version $VERSION

        Build Metadata:
        - Git SHA: ${{ steps.version.outputs.git_sha }}
        - Timestamp: ${{ steps.version.outputs.timestamp }}
        - Build Version: ${{ steps.version.outputs.build_version }}"
        
        # Push changes and tag
        git push origin main
        git push origin "v$VERSION"

  # Job 2: Build and Publish Immutable Artifacts
  build-and-publish:
    name: Build & Publish
    runs-on: ubuntu-latest
    needs: prepare-release
    if: needs.prepare-release.outputs.should_release == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main  # Ensure we have the updated VERSION file
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.prepare-release.outputs.version }}
          type=raw,value=${{ needs.prepare-release.outputs.git_sha }}
          type=raw,value=latest
        labels: |
          org.opencontainers.image.title=TTRPG Center
          org.opencontainers.image.description=AI-powered TTRPG content management platform
          org.opencontainers.image.version=${{ needs.prepare-release.outputs.version }}
          org.opencontainers.image.revision=${{ needs.prepare-release.outputs.git_sha }}
          org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/README.md
          org.opencontainers.image.created=${{ needs.prepare-release.outputs.timestamp }}
    
    - name: Build and push container image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: services/app/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          VERSION=${{ needs.prepare-release.outputs.build_version }}
          GIT_SHA=${{ needs.prepare-release.outputs.git_sha }}
          BUILD_TIMESTAMP=${{ needs.prepare-release.outputs.timestamp }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
    
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.version }}
        format: spdx-json
        output-file: sbom.spdx.json
    
    - name: Upload SBOM
      uses: actions/upload-artifact@v3
      with:
        name: sbom-${{ needs.prepare-release.outputs.version }}
        path: sbom.spdx.json
    
    - name: Generate image checksums
      run: |
        # Pull the image to get accurate digest
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.version }}
        
        # Get image digest
        IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.version }})
        
        # Create checksums file
        cat > checksums.txt << EOF
        Release: ${{ needs.prepare-release.outputs.version }}
        Build Version: ${{ needs.prepare-release.outputs.build_version }}
        Git SHA: ${{ needs.prepare-release.outputs.git_sha }}
        Timestamp: ${{ needs.prepare-release.outputs.timestamp }}
        Image Digest: ${IMAGE_DIGEST}
        
        Container Image Tags:
        - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.version }}
        - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.git_sha }}
        - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        EOF
    
    - name: Upload checksums
      uses: actions/upload-artifact@v3
      with:
        name: release-checksums-${{ needs.prepare-release.outputs.version }}
        path: checksums.txt

  # Job 3: Deploy to DEV Environment
  deploy-dev:
    name: Deploy to DEV
    runs-on: ubuntu-latest
    needs: [prepare-release, build-and-publish]
    if: needs.prepare-release.outputs.should_release == 'true' && github.event.inputs.skip_deploy != 'true'
    environment: 
      name: dev
      url: http://localhost:8000
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to DEV
      run: |
        VERSION="${{ needs.prepare-release.outputs.version }}"
        echo "Deploying version $VERSION to DEV environment"
        
        # This would typically include deployment steps like:
        # - SSH to deployment server
        # - Update docker-compose.dev.yml with new image tag
        # - Pull new image and restart services
        # - Run post-deployment health checks
        
        # For now, simulate deployment
        echo "🚀 Simulated DEV deployment for version $VERSION"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION"
        
        # In a real deployment, you would:
        # 1. Connect to DEV server
        # 2. Update environment configuration
        # 3. Pull new container image
        # 4. Restart services with new image
        # 5. Wait for health checks to pass
        # 6. Run smoke tests
    
    - name: Post-deployment health check
      run: |
        echo "Running post-deployment health checks..."
        
        # Simulate health check
        # In real deployment, this would:
        # - Check /healthz endpoint
        # - Verify all services are running
        # - Validate database connections
        # - Test basic functionality
        
        echo "✅ Health checks passed"
    
    - name: Run smoke tests
      run: |
        echo "Running smoke tests..."
        
        # Simulate smoke tests
        # In real deployment, this would run:
        # - Basic API endpoint tests
        # - Authentication flow validation
        # - Database connectivity tests
        # - Critical user journey validation
        
        echo "✅ Smoke tests passed"

  # Job 4: Create GitHub Release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-and-publish, deploy-dev]
    if: always() && needs.prepare-release.outputs.should_release == 'true' && needs.build-and-publish.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        path: release-artifacts
    
    - name: Generate release notes
      id: release_notes
      run: |
        VERSION="${{ needs.prepare-release.outputs.version }}"
        BUILD_VERSION="${{ needs.prepare-release.outputs.build_version }}"
        GIT_SHA="${{ needs.prepare-release.outputs.git_sha }}"
        
        # Get commits since last release
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        if [ -n "$LAST_TAG" ]; then
          COMMIT_RANGE="${LAST_TAG}..HEAD"
        else
          COMMIT_RANGE="HEAD"
        fi
        
        # Generate release notes
        cat > release_notes.md << EOF
        ## TTRPG Center Release $VERSION
        
        **Build Information:**
        - Version: \`$VERSION\`
        - Build Version: \`$BUILD_VERSION\`
        - Git SHA: \`$GIT_SHA\`
        - Build Date: \`${{ needs.prepare-release.outputs.timestamp }}\`
        
        **Container Images:**
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION\` (immutable)
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$GIT_SHA\` (content-addressed)
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\` (floating)
        
        **Changes in this release:**
        \`\`\`
        $(git log --oneline --pretty=format:"- %s (%h)" $COMMIT_RANGE)
        \`\`\`
        
        **Deployment Status:**
        - ✅ DEV Environment: Deployed and validated
        - ⏳ TEST Environment: Ready for promotion (manual approval required)
        - 📋 PROD Environment: Not configured
        
        **Security:**
        - Container images scanned with Trivy
        - Dependencies scanned with Safety
        - Code scanned with Bandit
        - SBOM included in release artifacts
        
        **Artifacts:**
        - Software Bill of Materials (SBOM)
        - Release checksums and metadata
        - Container image manifests
        
        ---
        
        🤖 Generated with [Claude Code](https://claude.ai/code)
        
        Co-Authored-By: Claude <noreply@anthropic.com>
        EOF
    
    - name: Create GitHub release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.prepare-release.outputs.version }}
        name: Release ${{ needs.prepare-release.outputs.version }}
        body_path: release_notes.md
        draft: false
        prerelease: false
        files: |
          release-artifacts/**/*
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 5: Release Summary
  release-summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [prepare-release, build-and-publish, deploy-dev, create-release]
    if: always() && needs.prepare-release.outputs.should_release == 'true'
    
    steps:
    - name: Generate summary
      run: |
        VERSION="${{ needs.prepare-release.outputs.version }}"
        BUILD_STATUS="${{ needs.build-and-publish.result }}"
        DEPLOY_STATUS="${{ needs.deploy-dev.result }}"
        RELEASE_STATUS="${{ needs.create-release.result }}"
        
        echo "# 🚀 Release Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Release $VERSION" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Stage | Status | Details |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
        
        # Build status
        if [ "$BUILD_STATUS" == "success" ]; then
          echo "| 🏗️ Build & Publish | ✅ Success | Images published to registry |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| 🏗️ Build & Publish | ❌ Failed | Check build logs |" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Deploy status
        if [ "$DEPLOY_STATUS" == "success" ]; then
          echo "| 🚀 DEV Deployment | ✅ Success | Environment updated and validated |" >> $GITHUB_STEP_SUMMARY
        elif [ "$DEPLOY_STATUS" == "skipped" ]; then
          echo "| 🚀 DEV Deployment | ⏭️ Skipped | Manual skip requested |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| 🚀 DEV Deployment | ❌ Failed | Check deployment logs |" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Release status
        if [ "$RELEASE_STATUS" == "success" ]; then
          echo "| 📦 GitHub Release | ✅ Success | Release created with artifacts |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| 📦 GitHub Release | ❌ Failed | Check release creation logs |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "1. **TEST Promotion**: Use the [Promote to TEST workflow](.github/workflows/promote.yml) to deploy to TEST environment" >> $GITHUB_STEP_SUMMARY
        echo "2. **Rollback**: If needed, use the [Rollback workflow](.github/workflows/rollback.yml)" >> $GITHUB_STEP_SUMMARY
        echo "3. **Monitoring**: Check DEV environment health and performance" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## Container Images" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$VERSION\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare-release.outputs.git_sha }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`" >> $GITHUB_STEP_SUMMARY

  # Job 6: Notify on Failure
  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [prepare-release, build-and-publish, deploy-dev]
    if: failure() && needs.prepare-release.outputs.should_release == 'true'
    
    steps:
    - name: Report failure
      run: |
        echo "# ❌ Release Pipeline Failed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The release pipeline encountered an error. Please check the failed jobs:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Prepare Release**: ${{ needs.prepare-release.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build & Publish**: ${{ needs.build-and-publish.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deploy DEV**: ${{ needs.deploy-dev.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Recovery Actions:**" >> $GITHUB_STEP_SUMMARY
        echo "1. Review failed job logs for specific error details" >> $GITHUB_STEP_SUMMARY
        echo "2. Fix any identified issues" >> $GITHUB_STEP_SUMMARY
        echo "3. Re-run the workflow or push a new commit to trigger release" >> $GITHUB_STEP_SUMMARY
