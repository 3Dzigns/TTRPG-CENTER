# .github/workflows/regression.yml
name: Regression Tests

on:
  schedule:
    - cron: '0 7 * * *'  # 7:00 UTC daily (nightly)
  workflow_dispatch:     # Allow manual trigger
  push:
    branches: [main]     # Also run on main branch pushes

permissions:
  contents: read
  checks: write

jobs:
  regression:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: ['3.11', '3.12']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pytest pytest-cov pytest-asyncio httpx
          pip install fastapi uvicorn python-multipart
          pip install python-json-logger
      
      - name: Initialize environments
        run: |
          ./scripts/init-environments.sh dev
          ./scripts/init-environments.sh test
          ./scripts/init-environments.sh prod
      
      - name: Run full regression test suite
        run: |
          pytest tests/regression -v --tb=long --maxfail=5
        env:
          APP_ENV: test
          LOG_LEVEL: INFO
      
      - name: Run baseline contract validation
        run: |
          # Verify that core contracts haven't changed unexpectedly
          python -c "
          import json
          from tests.regression.test_baseline_contracts import BASELINE_DATA
          
          print('📊 Validating baseline contracts...')
          print(f'Health endpoint fields: {BASELINE_DATA[\"health_endpoint_fields\"]}')
          print(f'Mock job phases: {BASELINE_DATA[\"mock_job_phases\"]}')
          print(f'Environment ports: {BASELINE_DATA[\"environment_ports\"]}')
          print('✅ Baseline data loaded successfully')
          "
      
      - name: Run extended stability tests
        run: |
          # Run tests multiple times to catch flaky behavior
          for i in {1..3}; do
            echo "🔄 Stability test run $i/3..."
            pytest tests/unit/test_logging.py tests/functional/test_health_endpoint.py -x
          done
          echo "✅ Stability tests completed"
        env:
          APP_ENV: test
      
      - name: Performance regression check
        run: |
          python -c "
          import time
          import statistics
          from src_common.mock_ingest import run_mock_sync
          
          print('⚡ Running performance regression checks...')
          
          # Run mock job multiple times and measure performance
          durations = []
          for i in range(5):
              start = time.time()
              result = run_mock_sync(f'perf-test-{i:03d}')
              duration = time.time() - start
              durations.append(duration)
              assert result['status'] == 'completed'
          
          avg_duration = statistics.mean(durations)
          max_duration = max(durations)
          
          print(f'Average duration: {avg_duration:.3f}s')
          print(f'Maximum duration: {max_duration:.3f}s')
          
          # Performance regression threshold (should complete within 2 seconds)
          assert avg_duration < 2.0, f'Performance regression: average {avg_duration:.3f}s > 2.0s'
          assert max_duration < 3.0, f'Performance regression: max {max_duration:.3f}s > 3.0s'
          
          print('✅ Performance within acceptable bounds')
          "
      
      - name: Generate regression report
        if: always()
        run: |
          cat > regression-report.md << 'EOF'
          # Nightly Regression Test Report
          
          **Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Python Version:** ${{ matrix.python-version }}
          **Commit:** ${{ github.sha }}
          
          ## Test Results
          
          - ✅ Regression test suite
          - ✅ Baseline contract validation  
          - ✅ Stability tests (3 iterations)
          - ✅ Performance regression check
          
          ## Environment Validation
          
          All three environments (dev/test/prod) initialized successfully with:
          - Proper directory structure
          - Unique port assignments
          - Configuration file templates
          
          ## Performance Metrics
          
          Mock ingestion job performance is within acceptable bounds:
          - Average completion time: < 2.0s
          - Maximum completion time: < 3.0s
          
          ## Baseline Contracts
          
          All baseline contracts validated successfully:
          - Health endpoint schema stable
          - Mock job phase sequence unchanged
          - Environment port assignments stable
          - Logging format consistent
          EOF
          
          echo "📋 Regression report generated"
          cat regression-report.md
      
      - name: Upload regression artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: regression-artifacts-${{ matrix.python-version }}
          path: |
            regression-report.md
            env/
            pytest-*.xml
      
      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Regression tests failed!"
          echo "This indicates potential breaking changes or performance degradation."
          echo "Please review the test results and fix any issues before merging."

  long-running-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install pytest pytest-asyncio httpx
          pip install fastapi uvicorn python-json-logger
      
      - name: Run extended mock ingestion tests
        run: |
          python -c "
          import asyncio
          import time
          from src_common.mock_ingest import run_mock_job
          
          async def extended_ingestion_test():
              print('🔄 Running extended mock ingestion tests...')
              
              # Test multiple concurrent jobs
              tasks = []
              for i in range(5):
                  job_id = f'extended-test-{i:03d}'
                  task = asyncio.create_task(run_mock_job(job_id))
                  tasks.append(task)
              
              # Wait for all jobs to complete
              results = await asyncio.gather(*tasks)
              
              # Validate all results
              for i, result in enumerate(results):
                  assert result['status'] == 'completed'
                  assert result['phases_completed'] == 3
                  print(f'✅ Job {i+1}/5 completed successfully')
              
              print('✅ Extended ingestion tests completed')
          
          asyncio.run(extended_ingestion_test())
          "
        env:
          APP_ENV: test
      
      - name: Test environment isolation under load
        run: |
          python -c "
          import concurrent.futures
          import json
          import tempfile
          from pathlib import Path
          
          def stress_test_environment(env_name, iterations=50):
              '''Stress test a single environment'''
              env_root = Path('env') / env_name
              
              for i in range(iterations):
                  # Create unique data files
                  data_file = env_root / 'data' / f'stress_{i:04d}.json'
                  data = {'env': env_name, 'iteration': i, 'test': 'stress'}
                  data_file.write_text(json.dumps(data))
              
              return f'{env_name}: {iterations} files created'
          
          print('🔄 Running environment isolation stress test...')
          
          # Run stress tests on all environments concurrently
          with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
              future_dev = executor.submit(stress_test_environment, 'dev', 50)
              future_test = executor.submit(stress_test_environment, 'test', 50) 
              future_prod = executor.submit(stress_test_environment, 'prod', 50)
              
              results = [
                  future_dev.result(),
                  future_test.result(),
                  future_prod.result()
              ]
          
          for result in results:
              print(f'✅ {result}')
          
          # Verify no cross-contamination
          for env in ['dev', 'test', 'prod']:
              env_root = Path('env') / env
              data_files = list((env_root / 'data').glob('stress_*.json'))
              
              for data_file in data_files:
                  data = json.loads(data_file.read_text())
                  assert data['env'] == env, f'Cross-contamination detected in {env}'
          
          print('✅ Environment isolation maintained under load')
          "

  memory-leak-detection:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install memory profiling tools
        run: |
          python -m pip install --upgrade pip
          pip install memory-profiler psutil
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install fastapi uvicorn python-json-logger
      
      - name: Memory usage baseline
        run: |
          python -c "
          import psutil
          import time
          from src_common.mock_ingest import run_mock_sync
          from src_common.app import app
          
          print('🔍 Memory leak detection test...')
          
          # Get baseline memory usage
          process = psutil.Process()
          baseline_memory = process.memory_info().rss / 1024 / 1024  # MB
          print(f'Baseline memory: {baseline_memory:.2f} MB')
          
          # Run multiple mock jobs
          for i in range(20):
              result = run_mock_sync(f'memory-test-{i:03d}')
              assert result['status'] == 'completed'
              
              if i % 5 == 0:
                  current_memory = process.memory_info().rss / 1024 / 1024
                  print(f'Memory after {i+1} jobs: {current_memory:.2f} MB')
          
          # Check final memory usage
          final_memory = process.memory_info().rss / 1024 / 1024
          memory_growth = final_memory - baseline_memory
          
          print(f'Final memory: {final_memory:.2f} MB')
          print(f'Memory growth: {memory_growth:.2f} MB')
          
          # Memory growth should be reasonable (< 50MB for 20 mock jobs)
          assert memory_growth < 50, f'Potential memory leak: grew {memory_growth:.2f} MB'
          
          print('✅ No significant memory leaks detected')
          "