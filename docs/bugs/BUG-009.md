# BUG-009: No Entry/Exit Criteria Validation Per Pass

## Summary
The logs show Pass A runs, but there's no evidence of **output contract validation** (schema, dedup count, checksum) before advancing. Phase 1 requires **hard gates** where each pass must verify outputs before proceeding.

## Environment
- **Script:** `scripts/bulk_ingest.py`
- **Pipeline:** 6-Pass (A–F) validation system
- **Validation:** Missing output contract verification
- **Env:** DEV
- **Observed Date:** 2025-09-08

## Description of Issue
The ingestion pipeline lacks proper validation gates between passes:
- No output contract validation before pass transitions
- Missing schema validation for generated chunks
- No integrity checks for dictionary updates
- Absence of hard failure mechanisms when validation fails

## Impact
- **Data Quality**: Bad/malformed chunks can silently flow into database
- **Dictionary Corruption**: Dictionary entries may be corrupted without detection
- **Pipeline Integrity**: Violates Phase 1 "job fails hard if pass fails" rule
- **Silent Failures**: Problems not detected until much later in pipeline

## Root Cause Analysis
1. **Missing Validation Gates**: No output validation between pass transitions
2. **No Schema Enforcement**: Generated data not validated against expected schemas
3. **Soft Failures**: System continues processing even when validation should fail
4. **Insufficient Contracts**: Output contracts not clearly defined or enforced

## Expected Behavior
- Each pass must validate its outputs before advancing to next pass
- Schema validation ensures data integrity
- Hard failures stop processing when validation fails
- Clear output contracts define expected results from each pass

## Actual Behavior
- Passes advance without output validation
- Malformed data can silently propagate through pipeline
- No hard stops when validation should fail

## Proposed Fix
1. **Add Validators After Each Pass**
   - **Pass A**: JSON schema check for extracted chunks
   - **Pass B**: Dictionary delta validation and consistency check
   - **Pass C**: Graph integrity and relationship validation
2. **Hard Failure Implementation**
   - Fail ingestion job immediately if validation fails
   - Provide clear error messages indicating validation failure
3. **Output Contract Definition**
   - Define clear schemas for each pass output
   - Implement automated contract testing

## Technical Implementation
```python
from pydantic import BaseModel, ValidationError
from typing import List, Dict, Any
import jsonschema

class PassAOutput(BaseModel):
    chunks: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    source_id: str
    extracted_at: datetime

class PassBOutput(BaseModel):
    dictionary_updates: List[Dict[str, Any]]
    enriched_chunks: List[Dict[str, Any]]
    enrichment_metadata: Dict[str, Any]

class PassValidator:
    def __init__(self):
        self.schemas = self._load_schemas()
    
    def validate_pass_a_output(self, output: Dict[str, Any]) -> bool:
        try:
            PassAOutput(**output)
            # Additional business logic validation
            return self._validate_chunk_integrity(output['chunks'])
        except ValidationError as e:
            logger.error(f"Pass A output validation failed: {e}")
            return False
    
    def validate_pass_b_output(self, output: Dict[str, Any]) -> bool:
        try:
            PassBOutput(**output)
            # Validate dictionary delta makes sense
            return self._validate_dictionary_delta(output['dictionary_updates'])
        except ValidationError as e:
            logger.error(f"Pass B output validation failed: {e}")
            return False
    
    def _validate_chunk_integrity(self, chunks: List[Dict]) -> bool:
        # Check chunk count, size distribution, content quality
        if len(chunks) == 0:
            logger.error("No chunks extracted - possible parsing failure")
            return False
        
        # Validate chunk structure
        for i, chunk in enumerate(chunks):
            if not chunk.get('content', '').strip():
                logger.error(f"Chunk {i} has empty content")
                return False
                
        return True

class IngestionPipeline:
    def __init__(self):
        self.validator = PassValidator()
    
    def run_pass_a(self, source_file: str) -> Dict[str, Any]:
        # Execute pass A processing
        output = self._execute_pass_a(source_file)
        
        # Validate output before proceeding
        if not self.validator.validate_pass_a_output(output):
            raise ValidationError("Pass A output validation failed - stopping pipeline")
        
        return output
```

## Acceptance Criteria
- ✅ Each pass validates its outputs before advancing
- ✅ Malformed chunks cause Pass A to fail hard
- ✅ Dictionary corruption causes Pass B to fail hard
- ✅ Graph integrity issues cause Pass C to fail hard
- ✅ Clear error messages provided for validation failures
- ✅ Pipeline stops immediately on validation failure

## Automated Tests

### Unit Tests
- **Schema Validation**: Inject bad chunk; Pass A fails, job stops
- **Dictionary Validation**: Corrupted dictionary updates cause Pass B failure
- **Graph Validation**: Invalid graph structures cause Pass C failure
- **Error Messages**: Validation failures provide clear, actionable error messages

### Functional Tests
- **Valid Processing**: Ingest valid book → all passes succeed with validation
- **Invalid Input**: Ingest malformed PDF → halted at failing pass with clear error
- **Partial Corruption**: Mixed valid/invalid data properly handled

### Regression Tests
- **Golden Fixtures**: Golden fixture PDFs still succeed with validation enabled
- **Performance Impact**: Validation doesn't significantly slow ingestion
- **Backward Compatibility**: Existing valid data continues to pass validation

### Security Tests
- **Malicious Input**: Validate inputs against malicious PDFs (script injection, XXE)
- **Resource Exhaustion**: Validation doesn't allow DoS through resource exhaustion
- **Input Sanitization**: Malicious content properly sanitized or rejected

## Definition of Done
- Validation gates implemented between all pass transitions
- Hard failure mechanisms stop processing on validation errors
- Clear output contracts defined and enforced
- All tests pass (Unit/Functional/Regression/Security)
- Comprehensive error reporting for validation failures
- Documentation updated with validation requirements and contracts