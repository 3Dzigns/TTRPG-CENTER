# BP003 — Phase 3 Bug Report: Planner fails to expand steps due to GraphStore.neighbors bug

Date: 2025-09-04
Owner: Phase 3
Severity: High
Status: Open

## Summary
Phase 3 workflow planning produces only the generic 3-task sequence instead of step-level tasks derived from the procedure graph. Root cause is an error in `GraphStore.neighbors` that returns an empty list for direct (depth=1) neighbors, preventing the planner from discovering `Step` nodes linked by `part_of` edges.

## Impact
- Functional test fails: `tests/functional/test_phase3_workflows.py:115` expects ≥5 tasks but gets 3.
- Planner does not decompose procedures into step-level tasks, undermining long-horizon workflows.
- Downstream components (graph-walk reasoning, provenance, checkpoints) are less effective due to missing step granularity.

## Evidence
- Test failure (reproducible):
  - File: `tests/functional/test_phase3_workflows.py:115`
  - Assertion: `assert len(plan.tasks) >= 5`
  - Logs show: `Expanded procedure proc:craft:healing_potion into 0 steps`
    - Source: `src_common/planner/plan.py:205` (`_expand_steps` calls `graph_store.neighbors(... etypes=["part_of"], depth=1)` and then filters for `type == "Step"`).

- Minimal reproduction (interactive snippet):
  ```python
  from src_common.graph.store import GraphStore
  s = GraphStore()
  s.upsert_node('proc:test','Procedure',{'name':'Test'})
  s.upsert_node('step:1','Step',{'name':'Step 1','step_number':1})
  s.upsert_edge('proc:test','part_of','step:1',{})
  assert s.neighbors('proc:test', etypes=['part_of'], depth=1) != [], "expected step neighbor"
  # Actual: returns []
  ```

## Root Cause Analysis
- File: `src_common/graph/store.py:246` (`neighbors`)
- The BFS traversal tracks `visited` nodes (processed frontiers) and returns `visited - {start}` as neighbors. With `depth=1`, only the start node is processed and added to `visited`. First-hop neighbors are collected into `next_level` but never added to the returned set, resulting in an empty neighbor list. The function conflates “processed nodes” with “discovered neighbor nodes.”

## Proposed Fix
Adjust `neighbors` to accumulate discovered neighbor IDs during traversal (e.g., `result_ids`) and return those, not just processed nodes. Also retain security limits (depth and MAX_NEIGHBORS) and etype filtering.

Suggested patch (conceptual):
```python
def neighbors(self, node_id: str, etypes: Optional[List[EdgeType]] = None, depth: int = 1) -> List[Dict[str, Any]]:
    depth = min(depth, self.MAX_DEPTH)
    if node_id not in self.nodes:
        return []

    visited = set([node_id])            # processed nodes
    frontier = {node_id}                # current frontier
    result_ids = set()                  # discovered neighbor ids

    for _ in range(depth):
        next_frontier = set()
        for current in frontier:
            # Explore edges
            for edge in self.edges.values():
                if edge.source == current and (etypes is None or edge.type in etypes):
                    if edge.target not in visited:
                        result_ids.add(edge.target)
                        next_frontier.add(edge.target)
                elif edge.target == current and (etypes is None or edge.type in etypes):
                    if edge.source not in visited:
                        result_ids.add(edge.source)
                        next_frontier.add(edge.source)
        visited.update(frontier)
        frontier = next_frontier
        if len(result_ids) > self.MAX_NEIGHBORS:
            logger.warning("Neighbor search truncated at MAX_NEIGHBORS")
            break

    return [asdict(self.nodes[nid]) for nid in result_ids if nid in self.nodes]
```

## Additional Findings (Phase 3 Code Review)
1) Missing import in API surface
- File: `app_plan_run.py:91` uses `asdict(task)` but `asdict` is not imported.
- Effect: Calling `/plan` path that serializes tasks will raise `NameError`.
- Action: Add `from dataclasses import asdict` to imports.

2) Model fallback logic robustness
- File: `src_common/planner/budget.py:402`
- Issue: `current_cost = self.budget_manager.models.get(current_model, {}).cost_per_1k_tokens` may `AttributeError` if model key is unknown (dict fallback has no attribute). The subsequent `isinstance(current_cost, ModelConfig)` is unreachable because `current_cost` is a float at that point.
- Action: Retrieve `ModelConfig` first and then access fields, with safe default.

3) Enum duplication for task status
- Files: `src_common/runtime/execute.py:19` and `src_common/runtime/state.py:18` both define `TaskStatus` enums.
- Risk: Mixed enum types across modules may cause subtle comparison/serialization issues. Current serialization converts enums to string, which mitigates, but duplication is error-prone.
- Action: Consolidate to a single shared enum or ensure consistent aliasing.

4) Graph query stub limitations (non-blocking)
- File: `src_common/graph/store.py:312` (`query`)
- Observation: Very limited pattern handling (only detects `n:Procedure` and applies equality on provided params). Acceptable as a stub, but document limitations to avoid misuse in production.

## User Stories and Acceptance Criteria

US-BP003-1: Correct Neighbor Traversal
- As: Systems Architect
- I want: `GraphStore.neighbors` to return correct neighbor nodes up to a specified depth with optional edge-type filtering.
- So that: Planners and reasoners can traverse the graph reliably.
- Acceptance:
  - Given a Procedure with `part_of` edges to 5 Steps, `neighbors(proc_id, etypes=["part_of"], depth=1)` returns those 5 Step nodes.
  - Depth > 1 returns transitive neighbors without duplicates, capped by `MAX_DEPTH` and `MAX_NEIGHBORS`.
  - Unit tests cover: outgoing only, incoming only, mixed, cycles, and etype filtering.

US-BP003-2: Planner Step Expansion Integration
- As: Orchestrator Engineer
- I want: The planner to expand procedures into step-level tasks when steps are present in the graph.
- So that: Workflows reflect explicit steps and dependencies.
- Acceptance:
  - Functional test `test_craft_potion_planning` passes: ≥5 tasks created, `procedure_id` matches, and plan validates.
  - Add unit tests that mock `GraphStore.neighbors` to return Step nodes and assert task DAG edges reflect sequence (`prereq` → sequential dependencies).

US-BP003-3: API Serialization Reliability
- As: API Consumer
- I want: `/plan` to serialize tasks without runtime errors.
- So that: Clients can preview plans and estimates consistently.
- Acceptance:
  - Import `asdict` and ensure `/plan` returns JSON with `tasks` serialized.
  - Add an integration test that exercises `create_plan` and validates JSON structure (tasks, edges, estimates, checkpoints).

US-BP003-4: Budget Model Fallback Safety
- As: Platform Engineer
- I want: Model fallback logic to handle unknown models gracefully.
- So that: Policy enforcement and optimization never crash on unknown/removed models.
- Acceptance:
  - Replace direct `.get(..., {})` attribute access with a safe default `ModelConfig` and explicit check.
  - Unit tests for unknown model names confirm no exceptions and sensible alternatives list.

## Suggested Test Additions
- `tests/unit/test_graph_store_neighbors.py` covering one-hop and multi-hop cases with etype filtering and limits.
- Extend `tests/functional/test_phase3_workflows.py` to assert that step names from the graph appear in task names.
- Add an API test for `/plan` route serialization (mock planner for speed).

## Remediation Plan
1. Fix `GraphStore.neighbors` and add unit tests (US-BP003-1).
2. Validate planner step expansion end-to-end (US-BP003-2).
3. Patch API import and add a small integration test (US-BP003-3).
4. Harden budget fallback logic and add tests (US-BP003-4).

---
References:
- `src_common/graph/store.py:246`
- `src_common/planner/plan.py:205`
- `tests/functional/test_phase3_workflows.py:115`
- `app_plan_run.py:91`
- `src_common/planner/budget.py:402`

