# BR2 — Regression Test Failures and User Stories (Phases 0–2)

- Date: 2025-09-04
- Scope: Full test run across Phase 0, 1, 2 test suites (unit, functional, regression, security)
- Result Summary: 1 failed, 79 passed, 1 skipped, 3 warnings
- Environment: Python 3.12; tests executed with `pytest -q` from repo root

## Failure BR-SEC-001 — Security test contradiction in missing secret error message

- Failing Test: `tests/security/test_env_gitignore.py::TestSecretsHandlingSecurity::test_missing_required_secrets_fail_securely`

- Observed Output:
  - Assertion failure: `assert 'secret_' not in error_message.lower()`
  - Actual error message from `get_required_secret('NONEXISTENT_SECRET_KEY')` is:
    - "Required secret 'NONEXISTENT_SECRET_KEY' is missing or empty"
  - Lowercased, the substring "secret_" appears within the variable name `nonexistent_secret_key`.

- Why This Fails:
  - The test requires both:
    - The error message must include the literal key `NONEXISTENT_SECRET_KEY` (for diagnosability)
    - The message must not contain the substring `secret_` anywhere (to avoid hinting at secret patterns)
  - These two conditions conflict when the variable name itself contains `SECRET_`.

- Impact:
  - Single test failure in the security suite. Runtime behavior is safe: the function does not leak any actual secret values, and including the missing key name is standard dev/ops practice for diagnostics.

- Repro Steps:
  1. `from src_common.secrets import get_required_secret, SecretsError`
  2. `with pytest.raises(SecretsError) as exc: get_required_secret('NONEXISTENT_SECRET_KEY')`
  3. `msg = str(exc.value).lower()`
  4. Verify `"nonexistent_secret_key" in msg` and `"secret_" in msg` (the latter derives from the key itself).

- Root Cause:
  - Test logic is over-broad. It forbids the substring `secret_` globally, even when it originates from the explicit key name the test also requires to be present.

- Options to Fix:
  - Option A (preferred, test-only fix): Exempt the requested key from the forbidden-substring scan.
    - Example change in test:
      ```python
      error_message = str(excinfo.value)
      key = 'NONEXISTENT_SECRET_KEY'
      assert key in error_message
      sanitized_msg = error_message.lower().replace(key.lower(), '')
      assert 'sk-' not in sanitized_msg
      assert 'secret_' not in sanitized_msg
      ```
    - Rationale: Ensures no accidental hints beyond the key itself, while keeping actionable diagnostics.
  - Option B (behavioral change): Redact or rephrase the error to avoid the token `secret_` even inside the key.
    - Example: "Required configuration variable 'NONEXISTENT_SECRET_KEY' is missing." and additionally redact internal tokens: render the key as `NONEXISTENT_[REDACTED]_KEY`.
    - Trade-off: Reduces clarity and departs from common error messaging norms.

- Recommendation: Adopt Option A to correct the test and preserve high signal diagnostics.

### User Story (for Option A)

- As a QA engineer,
- I want the secret-handling tests to forbid leaking sensitive tokens other than the specific missing variable name provided,
- So that the error messages remain both secure and actionable.

- Acceptance Criteria:
  - Update `test_missing_required_secrets_fail_securely` to ignore the explicit key string when scanning for forbidden substrings.
  - New assertions: `sk-` and `secret_` are not present in the error message after removing the explicit key.
  - All tests pass: `pytest -q` yields zero failures on the current codebase.

- Tasks:
  - Edit the test as specified.
  - Run full suite locally and in CI.
  - Document the testing rationale in a short comment in the test function.

- Risks / Notes:
  - None; change is limited to test logic and aligns with the stated security intent.

---

## Test Run Metadata

- Command: `python -m pytest -q`
- Outcome: `1 failed, 79 passed, 1 skipped, 3 warnings`
- Warnings: pytest-asyncio deprecation notices; httpx ASGITransport deprecation (informational, not blocking).

