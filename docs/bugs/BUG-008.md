# BUG-008: Multi-Threading Race Condition Across Passes

## Summary
Log shows **Pass A starts simultaneously for multiple PDFs**. Since dictionary cleanup happens globally, threads interfere. This violates requirement that "single source cannot move to next Pass until all threads for current pass complete."

## Environment
- **Script:** `scripts/bulk_ingest.py`
- **Pipeline:** 6-Pass (A–F) multi-threaded execution
- **Threading:** Multiple PDFs processed concurrently
- **Env:** DEV
- **Observed Date:** 2025-09-08

## Description of Issue
The multi-threaded ingestion pipeline has race conditions where:
- Multiple PDFs start Pass A simultaneously
- Global dictionary cleanup interferes between threads
- Pass transitions happen without proper synchronization
- Thread interference causes partial ingestion results

## Impact
- **Data Corruption**: Partial ingestion results due to thread interference
- **Dictionary Inconsistency**: Dictionary entries overwritten mid-pass by other threads
- **Pipeline Integrity**: Downstream Pass B/C may not run on correct input
- **Requirements Violation**: Breaks sequential pass completion requirement

## Root Cause Analysis
1. **Simultaneous Pass Execution**: Multiple threads start same pass concurrently
2. **Global State Interference**: Dictionary cleanup affects all threads globally
3. **Missing Synchronization**: No thread-safe queues for Pass A→B→C transitions
4. **Inadequate Locking**: Per-document job locks not properly implemented

## Expected Behavior
- Single source must complete Pass A before starting Pass B
- Global cleanup must complete before any parallel ingestion begins
- Thread-safe transitions between passes
- No interference between concurrent PDF processing

## Actual Behavior
- Pass A starts simultaneously for multiple PDFs
- Dictionary cleanup interferes between threads
- Partial ingestion results due to race conditions

## Proposed Fix
1. **Per-Document Job Locks**
   - Introduce **per-document job locks**: one PDF must complete Pass A before starting Pass B
   - Ensure sequential pass progression within each document
2. **Global Operation Sequencing**
   - Global cleanup must complete before any parallel ingestion begins
   - Separate initialization phase from processing phase
3. **Thread-Safe Queues**
   - Add thread-safe queues for Pass A→B→C transitions
   - Implement proper synchronization mechanisms
4. **Lock Management**
   - Add timeout + retry mechanisms to prevent deadlocks
   - Implement proper lock cleanup on failure

## Technical Implementation
```python
import threading
import queue
from contextlib import contextmanager

class ThreadSafeIngestionManager:
    def __init__(self):
        self.document_locks = {}
        self.global_lock = threading.Lock()
        self.pass_queues = {
            'A': queue.Queue(),
            'B': queue.Queue(), 
            'C': queue.Queue()
        }
    
    @contextmanager
    def document_lock(self, doc_id, timeout=300):
        if doc_id not in self.document_locks:
            self.document_locks[doc_id] = threading.Lock()
        
        acquired = self.document_locks[doc_id].acquire(timeout=timeout)
        if not acquired:
            raise TimeoutError(f"Could not acquire lock for document {doc_id}")
        
        try:
            yield
        finally:
            self.document_locks[doc_id].release()
    
    def process_document_sequential(self, doc_id):
        with self.document_lock(doc_id):
            self.run_pass_a(doc_id)
            self.run_pass_b(doc_id) 
            self.run_pass_c(doc_id)
```

## Acceptance Criteria
- ✅ Two PDFs ingest simultaneously without race errors
- ✅ Dictionary contains entries from all PDFs after concurrent ingestion
- ✅ Pass A completes for each document before Pass B begins
- ✅ Global operations complete before parallel processing begins
- ✅ No deadlocks or timeout issues under normal operation

## Automated Tests

### Unit Tests
- **Lock Acquisition**: Document locks properly acquired and released
- **Sequential Passes**: Pass A completes before Pass B for same document
- **Timeout Handling**: Lock timeouts properly handled without deadlock

### Functional Tests
- **Concurrent Safety**: Two PDFs ingest simultaneously without race errors
- **Data Integrity**: Dictionary contains entries from all PDFs after concurrent processing
- **Pass Ordering**: Passes execute in correct order A→B→C for each document

### Regression Tests
- **Sequential Compatibility**: Sequential ingestion still passes all existing tests
- **Performance**: Multi-threaded performance maintained with proper synchronization
- **Error Recovery**: System recovers gracefully from failed concurrent operations

### Security Tests
- **Deadlock Prevention**: Ensure locks can't deadlock (add timeout + retry)
- **Resource Management**: Proper cleanup of locks and threads on failure
- **DoS Protection**: Prevent thread exhaustion attacks

## Definition of Done
- Per-document job locks implemented with timeout protection
- Thread-safe pass transitions with proper queuing
- Global operations properly sequenced before parallel processing
- All tests pass (Unit/Functional/Regression/Security)
- No race conditions in multi-threaded ingestion
- Documentation updated with threading model and safety guarantees