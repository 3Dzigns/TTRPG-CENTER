# BUG-007: Dictionary Writes Overwritten Instead of Appended

## Summary
Log shows `findOneAndReplace` calls on `ttrpg_dictionary_dev` for each ToC entry. This overwrites instead of appending new dictionary terms, losing prior data.

## Environment
- **Script:** `scripts/bulk_ingest.py`
- **Database:** AstraDB `ttrpg_dictionary_dev` collection
- **Operation:** Dictionary term insertion
- **Env:** DEV
- **Observed Date:** 2025-09-08

## Description of Issue
The dictionary update mechanism uses `findOneAndReplace` operations that:
- Overwrites existing dictionary entries instead of appending new ones
- Loses prior dictionary data when processing multiple PDFs
- Prevents proper dictionary growth across ingestion runs
- Breaks the dynamic dictionary system requirements

## Impact
- **Data Loss**: Dictionary shrinks or fails to grow across multiple PDFs
- **Requirements Violation**: Breaks requirement for **dynamic dictionary system** (Phase 1, RAG-003)
- **Operational Degradation**: Reduced query quality due to incomplete dictionary
- **Audit Trail Loss**: No tracking of dictionary growth over time

## Root Cause Analysis
1. **Wrong Operation Type**: Using `findOneAndReplace` instead of upsert semantics
2. **No Append Logic**: No mechanism to add new terms while preserving existing ones
3. **Missing Deduplication**: No proper handling of duplicate entries
4. **No Audit Trail**: No tracking of when/how dictionary entries are added

## Expected Behavior
- New dictionary terms should be added while preserving existing entries
- Duplicate terms should be deduplicated but not cause data loss
- Dictionary should grow organically across multiple ingestion runs
- Audit trail should track dictionary growth and changes

## Actual Behavior
- Dictionary entries overwritten with each new PDF processing
- Dictionary size remains constant or decreases across runs
- Loss of previously ingested dictionary data

## Proposed Fix
1. **Use Upsert Semantics**
   - Replace `findOneAndReplace` with `upsert` operations
   - Use `$setOnInsert` + `$addToSet` (or Astra equivalent)
2. **Implement Audit Trail**
   - Maintain **audit trail** of dictionary growth (Phase 7 audit trail REQ-001/REQ-004)
   - Track when terms are added, source document, timestamp
3. **Proper Deduplication**
   - Remove exact duplicates while preserving unique entries
   - Handle case variations and synonym detection

## Technical Implementation
```python
# Instead of findOneAndReplace, use upsert pattern:
def upsert_dictionary_entry(term_data):
    collection.update_one(
        {"term": term_data["term"]},
        {
            "$setOnInsert": {
                "term": term_data["term"],
                "created_at": datetime.utcnow(),
                "sources": []
            },
            "$addToSet": {
                "sources": term_data["source"],
                "definitions": term_data["definition"]
            },
            "$set": {
                "updated_at": datetime.utcnow()
            }
        },
        upsert=True
    )
```

## Acceptance Criteria
- ✅ Multiple ToC entries from different books result in growing dictionary
- ✅ Existing dictionary entries preserved when new books ingested
- ✅ Deduplication removes exact duplicates without data loss
- ✅ Audit trail tracks dictionary growth and sources
- ✅ Dictionary size increases monotonically (except for explicit cleanup)

## Automated Tests

### Unit Tests
- **Upsert Logic**: Multiple ToC entries from different books result in >1 dictionary entry
- **Deduplication**: Exact duplicates removed while preserving unique entries
- **Audit Trail**: Dictionary changes properly logged with timestamps

### Functional Tests
- **Multi-Book Growth**: Ingest "Core Rulebook" then "Monster Manual"; dictionary size increases
- **Incremental Addition**: New books add terms without losing existing ones
- **Source Tracking**: Dictionary entries track which source documents contributed them

### Regression Tests
- **Data Preservation**: Deduplication still removes exact duplicates, but does not erase earlier books' terms
- **Performance**: Dictionary operations don't significantly slow ingestion
- **Consistency**: Dictionary remains consistent across concurrent ingestion runs

### Security Tests
- **Rate Limiting**: Prevent duplicate flooding (rate-limit dictionary writes)
- **Input Validation**: Malicious dictionary entries properly sanitized
- **Authorization**: Dictionary modifications require proper permissions

## Definition of Done
- Dictionary operations use proper upsert semantics
- Existing dictionary data preserved during new ingestions
- Audit trail implemented for dictionary changes
- All tests pass (Unit/Functional/Regression/Security)
- Dictionary grows organically across multiple ingestion runs
- Documentation updated with new dictionary behavior